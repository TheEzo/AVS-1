Architektura výpočetních systému (AVS 2019)
Projekt č. 1 (ANN)
Login: xwilla00

U každého kroku proveďte měření vypočtu pro dataset dostupný na https://www.fit.vutbr.cz/~ibordovsky/avs/datasets/bigDataset.h5
Správnost výpočtu můžete porovnat pomocí python 3 skriptu "Scripts/compareOutputs.py" s referenčním řešením.
Pro bigDataset je dostupný na https://www.fit.vutbr.cz/~ibordovsky/avs/datasets/bigRefOutput.h5

Krok 0: základní implementace
=============================
Celkový čas [s]: 193.966
Výkon skalárních operací [MFLOPS]:      37.5763
Výkon vektorových operací [MFLOPS]:     1143.16
L1 miss [%]:                            84.39576
L2 miss [%]:                            100
L3 miss [%]:                            0.00733

Které PAPI_EVENTS jste použili pro získání počtu výpadků v paměti?
HW countery pro L1: PAPI_L1_DCM, PAPI_SR_INS, PAPI_LD_INS
HW countery pro L2: PAPI_L2_TCM, PAPI_L2_TCA
HW countery pro L3: PAPI_L3_TCM, PAPI_L3_TCA


Krok 1: vektorizace funkcí
===================================
Celkový čas [s]: 38.0787
Výkon skalárních operací [MFLOPS]:      0.295345
Výkon vektorových operací [MFLOPS]:     5628.16
L1 miss [%]:                            49.64835
L2 miss [%]:                            99.8%
L3 miss [%]:                            0.0387%

Jaké pragmy bylo potřeba přidat?
- #pragma omp simd
Které dovětky k pragmám jste použili a jaky měly vliv na kompilátorem generované funkce? (main.cpp.optrpt/neuron.cpp.optrpt)
- #pragma omp declare simd simdlen(8) uniform(inputSize, neuronCount, input, weight) linear(neuronId)
  - uniform deklaruje, že pro každý krok simd smičky se hodnoty nemění, tudíž přednačítání dat je jednodušší
  - dovětky obecně zajišťují rychlejší průběh funkcí, pokud se nejedná o dovětek, který je použit bez znalosti čistě náhodně, takový může i rychlost vykonávání kódu zpomalit
    - v tomto případě se používají dovětky pro vektorizaci výpočtů


Krok 2: přístupy do paměti
=============================
a) S dovětky
(Sepište všechyn použité dovětky):
#pragma omp declare simd simdlen(8) uniform(inputSize, input, weight, bias)
#pragma omp declare simd simdlen(8) uniform(inputSize, input, bias) linear(weight:512)
#pragma omp declare simd simdlen(8) uniform(inputSize, input, bias) linear(weight:784)

Celkový čas [s]: 23.0166
Výkon skalárních operací [MFLOPS]:      175.766
Výkon vektorových operací [MFLOPS]:     14741.6
L1 miss [%]:                            14.834797
L2 miss [%]:                            48.2
L3 miss [%]:                            0.0616

b) Bez dovětků
Některé dovětky maji negativní dopad na výkon, přestože kompilátor tvrdí opak. Které?
Celkový čas [s]: 22.7625
Výkon skalárních operací [MFLOPS]:      176.077
Výkon vektorových operací [MFLOPS]:     14730.7
L1 miss [%]:                            14.92542
L2 miss [%]:                            47.9
L3 miss [%]:                            0.0621

Proč mají dovětky negativní efekt na výkon?
(neklasifikovana odpověď, můžete vynechat, ale může vynést přiklonění k bodu u věcí které jsou na hraně :-) )
- Podle obecné diskuze by to mělý být dovětky linear(weight:N), avšak to se u tohohle kódu prokázat nepodařilo, jelikož kód běží stejně rychle
- Teoretické zpomalení vidím v tím, že uniform deklaruje, že proměnná se neliší v žádném kroku cyklu, avšak linear vytváří privátní proměnnou pro každý krok smyčky


Krok 3.1: přesun #pragma omp simd
===================================
Celkový čas [s]: 22.7543
Výkon skalárních operací [MFLOPS]:      177.398
Výkon vektorových operací [MFLOPS]:     14844.9
L1 miss [%]:                            14.9176
L2 miss [%]:                            47.8
L3 miss [%]:                            0.0848

Jaký dovětek je potřeba přidat?
- reduction(+:result)

Krok 3.2: vykonání po vrstvách místo po obrázcích
===================================
Celkový čas [s]: 21.7303
Výkon skalárních operací [MFLOPS]:      298.787
Výkon vektorových operací [MFLOPS]:     14018
L1 miss [%]:                            15.42353
L2 miss [%]:                            54.9
L3 miss [%]:                            0.184

Popište, jaký dopad na výkon mají výpadky v cache.
- Při výpadku je potřeba data hledat na vyšší úrovní, tedy L2, L3, RAM, Disk, což zpožďuje vykonávání kódu o stovky až tisíce taktů

Krok 4: režie funkcí, zarovnání paměti
===================================
Celkový čas [s]: 20.5417
Výkon skalárních operací [MFLOPS]:      24.1611
Výkon vektorových operací [MFLOPS]:     16374.6
L1 miss [%]:                            16.23403
L2 miss [%]:                            57.1
L3 miss [%]:                            0.124

Proč není zrychlení již výrazné? Na jaké typy problémů cílí tyto optimalizace?
- Prefetcher načítá jen určitý blok dat pro výpočet, který se vejde do paměti cache
- Zarovnaná alokace cílí na úlohy, které používají velké množství dat, které se nevejdou do paměti jako jeden celek
